package converter

import (
	"log"
	"regexp"
	"time"
)

type lwtOutputMessage struct {
	timeStamp   time.Time
	measurement string
	device      string
	value       bool
}

var lwtTopicMatcher = regexp.MustCompile("^([^/]*/)*tele/(.*)/LWT$")

func init() {
	registerHandler("lwt", lwtHandler)
}

// parses availability messages generated by Tasmota as well as other tools and write one point per value to influxdb
// example inputs:
// - piegn/tele/mezzo/zimmer-klein/LWT Offline
// - piegn/tele/software/hass0/LWT Online
// - piegn/tele/software/srv1-go-iotdevice/LWT Online
func lwtHandler(c Config, input Input, outputFunc OutputFunc) {
	// parse topic
	matches := lwtTopicMatcher.FindStringSubmatch(input.Topic())
	if len(matches) < 3 {
		log.Printf("lwt[%s]: cannot extract device from topic='%s", c.Name(), input.Topic())
		return
	}
	device := matches[2]

	// parse payload
	var value bool
	switch string(input.Payload()) {
	case "Online":
		value = true
	case "Offline":
		value = false
	default:
		log.Printf("lwt[%s]: unknown LWT value='%s'", c.Name(), input.Payload())
		return
	}

	outputFunc(lwtOutputMessage{
		timeStamp:   time.Now(),
		measurement: c.TargetMeasurement(),
		device:      device,
		value:       value,
	})
}

func (m lwtOutputMessage) Measurement() string {
	return m.measurement
}

func (m lwtOutputMessage) Tags() map[string]string {
	return map[string]string{
		"device": m.device,
		"field":  "Available",
	}
}

func (m lwtOutputMessage) Fields() map[string]interface{} {
	return map[string]interface{}{
		"value": m.value,
	}
}

func (m lwtOutputMessage) Time() time.Time {
	return m.timeStamp
}
