package converter

import (
	"log"
	"regexp"
	"strings"
	"time"
)

type availabilityOutputMessage struct {
	timeStamp time.Time
	device    string
	value     bool
}

var availabilityTopicMatcher = regexp.MustCompile("^([^/]*/)*tele/(.*)/LWT$")

func init() {
	registerHandler("availability", availabilityHandler)
}

// parses availability messages generated by Tasmota as well as other tools and write one point per value to influxdb
// example inputs:
// - piegn/tele/mezzo/zimmer-klein/LWT Offline
// - piegn/tele/software/hass0/LWT Online
// - piegn/tele/software/srv1-go-iotdevice/LWT Online
func availabilityHandler(c Config, input Input, outputFunc OutputFunc) {
	// use our time
	timeStamp := time.Now()

	// parse topic
	matches := availabilityTopicMatcher.FindStringSubmatch(input.Topic())
	if len(matches) < 3 {
		log.Printf("availability[%s]: cannot extract device from topic='%s", c.Name(), input.Topic())
		return
	}
	device := matches[2]

	// parse payload
	var value bool
	payload := string(input.Payload())
	payload = strings.ToLower(payload)

	switch payload {
	case "online":
		value = true
	case "offline":
		value = false
	default:
		log.Printf("availability[%s]: unknown value='%s'", c.Name(), input.Payload())
		return
	}

	outputFunc(availabilityOutputMessage{
		timeStamp: timeStamp,
		device:    device,
		value:     value,
	})
}

func (m availabilityOutputMessage) Measurement() string {
	return "availability"
}

func (m availabilityOutputMessage) Tags() map[string]string {
	return map[string]string{
		"device": m.device,
	}
}

func (m availabilityOutputMessage) Fields() map[string]interface{} {
	return map[string]interface{}{
		"boolValue": m.value,
	}
}

func (m availabilityOutputMessage) Time() time.Time {
	return m.timeStamp
}
