package converter

import (
	"log"
	"strings"
	"time"
)

type availabilityOutputMessage struct {
	timeStamp time.Time
	device    string
	value     bool
}

func init() {
	registerHandler("availability", availabilityHandler)
}

// parses availability messages generated by Tasmota as well as other tools and write one point per value to influxdb
// example inputs:
// - piegn/tele/mezzo/zimmer-klein/LWT Offline
// - piegn/tele/software/hass0/LWT Online
// - piegn/tele/software/srv1-go-iotdevice/LWT Online
func availabilityHandler(c Config, tm TopicMatcher, input Input, outputFunc OutputFunc) {
	// use our time
	timeStamp := time.Now()

	// parse topic
	device, err := tm.MatchDevice(input.Topic())
	if err != nil {
		log.Printf("availability[%s]: error: %s", c.Name(), err)
		return
	}

	// parse pay load
	var value bool
	payload := string(input.Payload())
	payload = strings.ToLower(payload)

	switch payload {
	case "online":
		value = true
	case "offline":
		value = false
	default:
		log.Printf("availability[%s]: unknown value='%s'", c.Name(), input.Payload())
		return
	}

	outputFunc(availabilityOutputMessage{
		timeStamp: timeStamp,
		device:    device,
		value:     value,
	})
}

func (m availabilityOutputMessage) Measurement() string {
	return "availability"
}

func (m availabilityOutputMessage) Tags() map[string]string {
	return map[string]string{
		"device": m.device,
	}
}

func (m availabilityOutputMessage) Fields() map[string]interface{} {
	return map[string]interface{}{
		"boolValue": m.value,
	}
}

func (m availabilityOutputMessage) Time() time.Time {
	return m.timeStamp
}
